name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get current version
        id: current
        run: echo "version=$(jq -r .version apps/app/package.json)" >> $GITHUB_OUTPUT

      - name: Calculate new version
        id: new
        run: |
          current="${{ steps.current.outputs.version }}"
          IFS='.' read -r major minor patch <<< "$current"

          case "${{ inputs.version }}" in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac

          echo "version=$major.$minor.$patch" >> $GITHUB_OUTPUT

      - name: Update package.json
        run: |
          jq '.version = "${{ steps.new.outputs.version }}"' package.json > tmp.json
          mv tmp.json package.json
          jq '.version = "${{ steps.new.outputs.version }}"' apps/app/package.json > tmp.json
          mv tmp.json apps/app/package.json

      - name: Commit version bump
        run: |
          git add package.json apps/app/package.json
          git commit -m "chore: bump version to ${{ steps.new.outputs.version }}"
          git push

      - name: Create and push tag
        run: |
          git tag "v${{ steps.new.outputs.version }}"
          git push origin "v${{ steps.new.outputs.version }}"

      - name: Generate release notes
        id: notes
        run: |
          last_tag=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          new_version="${{ steps.new.outputs.version }}"

          if [ -z "$last_tag" ]; then
            commits=$(git log --pretty=format:"%h|%s" --no-merges)
          else
            commits=$(git log --pretty=format:"%h|%s" --no-merges "$last_tag"..HEAD^)
          fi

          repo="elitan/frost"

          breaking=""
          features=""
          fixes=""
          docs=""
          refactor=""
          perf=""

          # Parse commit: strip type prefix, capitalize, add links
          parse_commit() {
            local hash="$1"
            local msg="$2"

            # Strip type/scope prefix and capitalize first letter
            local text=$(echo "$msg" | sed -E 's/^[a-z]+(\([^)]+\))?!?: //' | sed 's/./\U&/')

            # Convert PR references (#123) to links
            text=$(echo "$text" | sed -E "s|#([0-9]+)|[#\1](https://github.com/$repo/pull/\1)|g")

            # Add commit link
            printf '%s ([`%s`](https://github.com/%s/commit/%s))' "$text" "$hash" "$repo" "$hash"
          }

          while IFS='|' read -r hash msg; do
            [ -z "$msg" ] && continue
            [[ "$msg" =~ ^chore: ]] && continue

            parsed=$(parse_commit "$hash" "$msg")

            if [[ "$msg" =~ !: ]] || [[ "$msg" =~ BREAKING ]]; then
              breaking="$breaking\n- $parsed"
            elif [[ "$msg" =~ ^feat ]]; then
              features="$features\n- $parsed"
            elif [[ "$msg" =~ ^fix ]]; then
              fixes="$fixes\n- $parsed"
            elif [[ "$msg" =~ ^docs ]]; then
              docs="$docs\n- $parsed"
            elif [[ "$msg" =~ ^refactor ]]; then
              refactor="$refactor\n- $parsed"
            elif [[ "$msg" =~ ^perf ]]; then
              perf="$perf\n- $parsed"
            fi
          done <<< "$commits"

          notes=""

          # Migration warning at top
          if [ -n "$last_tag" ]; then
            schema_changes=$(git diff --name-only "$last_tag" HEAD -- apps/app/schema/ | wc -l)
            if [ "$schema_changes" -gt 0 ]; then
              notes="> **This release includes database migrations.** Back up your data before updating.\n\n"
            fi
          fi

          [ -n "$breaking" ] && notes="$notes### Breaking Changes\n$breaking\n\n"
          [ -n "$features" ] && notes="$notes### Features\n$features\n\n"
          [ -n "$fixes" ] && notes="$notes### Fixes\n$fixes\n\n"
          [ -n "$perf" ] && notes="$notes### Performance\n$perf\n\n"
          [ -n "$refactor" ] && notes="$notes### Refactoring\n$refactor\n\n"
          [ -n "$docs" ] && notes="$notes### Documentation\n$docs\n\n"

          # Changelog link
          if [ -n "$last_tag" ]; then
            notes="$notes---\n**Full changelog:** [$last_tag â†’ v$new_version](https://github.com/elitan/frost/compare/$last_tag...v$new_version)"
          fi

          echo -e "$notes" > release_notes.md

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Build
        run: NEXT_TELEMETRY_DISABLED=1 bun run build

      - name: Create release tarball
        run: |
          VERSION="${{ steps.new.outputs.version }}"
          STANDALONE_APP=apps/app/.next/standalone/apps/app
          mkdir -p frost-release
          # Copy standalone output (monorepo structure: apps/app/.next/standalone/apps/app/)
          cp -r $STANDALONE_APP/. frost-release/
          cp -r apps/app/.next/standalone/node_modules frost-release/
          # Bun creates symlinks inside .bun/node_modules/ but server.js needs them at top level
          # Create top-level symlinks for packages that server.js requires
          cd frost-release/node_modules
          for pkg in .bun/node_modules/*; do
            name=$(basename "$pkg")
            [ -e "$name" ] || [ -L "$name" ] || ln -s ".bun/node_modules/$name" "$name"
          done
          cd ../..
          # Handle scoped packages (@next, @swc, etc.)
          for scope in frost-release/node_modules/.bun/node_modules/@*; do
            [ -d "$scope" ] || continue
            scope_name=$(basename "$scope")
            mkdir -p "frost-release/node_modules/$scope_name"
            for pkg in "$scope"/*; do
              name=$(basename "$pkg")
              [ -e "frost-release/node_modules/$scope_name/$name" ] || [ -L "frost-release/node_modules/$scope_name/$name" ] || \
                ln -s "../.bun/node_modules/$scope_name/$name" "frost-release/node_modules/$scope_name/$name"
            done
          done
          # Copy static files
          mkdir -p frost-release/.next
          cp -r apps/app/.next/static frost-release/.next/static
          # Copy additional required files
          cp -r apps/app/schema apps/app/scripts apps/app/templates frost-release/
          mkdir -p frost-release/src/lib
          cp -r apps/app/src/scripts frost-release/src/scripts
          cp apps/app/src/lib/migrate.ts apps/app/src/lib/paths.ts frost-release/src/lib/
          cp apps/app/package.json frost-release/
          cp install.sh update.sh cleanup.sh frost-release/
          tar -czf "frost-v${VERSION}.tar.gz" -C frost-release .
          rm -rf frost-release
          ls -lh "frost-v${VERSION}.tar.gz"

      - name: Test tarball
        run: |
          VERSION="${{ steps.new.outputs.version }}"
          mkdir -p /tmp/frost-test
          tar -xzf "frost-v${VERSION}.tar.gz" -C /tmp/frost-test
          cd /tmp/frost-test

          mkdir -p data
          bun run migrate
          bun run setup testpassword123

          FROST_JWT_SECRET=smoke-test-secret nohup bun server.js > /tmp/frost.log 2>&1 &
          SERVER_PID=$!
          sleep 5

          echo "=== Server log ==="
          cat /tmp/frost.log

          echo "=== Testing auth endpoint ==="
          RESPONSE=$(curl -sf -X POST http://localhost:3000/api/auth/login \
            -H "Content-Type: application/json" \
            -d '{"password":"testpassword123"}')
          echo "$RESPONSE"
          echo "$RESPONSE" | grep -q '"success":true' || { echo "Auth test failed"; kill $SERVER_PID 2>/dev/null; exit 1; }

          echo "=== Verifying static files ==="
          ls -la .next/static/ || { echo "Static files missing"; kill $SERVER_PID 2>/dev/null; exit 1; }

          kill $SERVER_PID 2>/dev/null || true
          echo "Tarball smoke test passed"

      - name: Create release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "v${{ steps.new.outputs.version }}" \
            --title "v${{ steps.new.outputs.version }}" \
            --notes-file release_notes.md \
            "frost-v${{ steps.new.outputs.version }}.tar.gz"
